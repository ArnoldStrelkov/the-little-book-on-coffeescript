##Классы в CoffeeScript

На приверженцев чисто объектно ориентированных языков классы в JavaScript действуют, как чеснок на Дракулу (хотя вряд ли Вы бы стали читать книгу по CoffeeScript, придерживайся Вы таких взглядов). Однако классы в JavaScript столь же полезны, сколь и в других языках, а CoffeeScript сильно упрощает работу с ними.

"За кулисами" CoffeeScript использует прототипирование JavaScript'а для создания классов, добавляя немного синтаксического сахара при наследовании статических свойств и определении контекста исполнения. Все что требуется написать разработчику - это:

```coffeescript
class Animal
```

В приведенном примере Animal - это название класса и одновременно полученной переменной, которую в дальнейшем можно использовать для создания экземпляров класса. Внутри CoffeeScript использует функции-конструкторы, что позволяет создавать объекты с помощью оператора `new`:

```coffeescript
animal = new Animal
```

Создать конструктор (функцию, вызываемую при создании экземпляра класса) очень просто - создайте функцию с именем `constructor`, аналогично методу `initialize` в Ruby или `__init__` в Python:

```coffeescript
class Animal
  constructor: (name) ->
    @name = name
```

Более того, CoffeeScript предоставляет элегантную реализацию распространненного способа установки исходных значений полей объекта. Префикс `@` автоматически превращает переменную в свойство экземпляра класса. На самом деле, этот синтаксический сахар работает даже для обыкновенных функций за пределами класса. Пример, приведенный ниже эквивалентен предыдущему:

```coffeescript
class Animal
  constructor: (@name) ->
```

Таким образом переменные, передаваемые при создании объекта, транслируются в конструктор:

```coffeescript
animal = new Animal("Parrot")
alert "Animal is a #{animal.name}
```

### Поля объекта

Добавление дополнительных свойста в объект класса является довольно прямолинейно: оно полностью совпадает с добавление свойств в обычный объект. Нужно только убедиться, что свойства добавлены тело класса.

```coffeescript
class Animal
  price: 5

  sell: (customer) ->

animal = new Animal
animal.sell(new Customer)
```

В JavaScript часто приходится прибегать к смене контекста. В главе Синтакис мы уже рассказывали о том, как привязать значение this к конкретному контексту, используя толстую стрелку =>. Так мы гарантируем, что функция будет выполняться в том контексте, в котором была создана, независимо от контекста, в котором она вызывается. CoffeeScript расширяет поддержку толстой стрелки для классов. Используя ее для методов объекта, мы гарантируем, что метод будет вызываться в контексте текущего объекта класса.

```coffeescript
class Animal
  price: 5

  sell: =>
    alert "Give me #{@price} shillings!"

animal = new Animal
$("#sell").click(animal.sell)
```

В примере, показаном выше, видно, что этот прием особенно полезент в функциях обратного вызова для событий. Если бы мы использовали тонкую стрелку, метод sell() был бы вызван в контексте элемента #sell. В нашем же случае мы гарантируем, что используется корректный контекст и this.price равен 5.

###Статические свойства

How about defining class (i.e. static) properties? Well, it turns out that inside a class definition, this refers to the class object. In other words you can set class properties by setting them directly on this.

А что на счет статических свойств? В CoffeeScript внутри определения класса this ссылается на сам объект класса. Другими словами, вы можете задать статические свойства класса, установив их непосредственно через this.

```coffeescript
class Animal
  this.find = (name) ->      

Animal.find("Parrot")
```

Вы уже знаете, что в CoffeeScript существует ??алиас??(псевдоним, синоним) для this - @, который позволяет нам писать статические свойства еще более кратко:

```coffeescript
class Animal
  @find: (name) ->

Animal.find("Parrot")
```

###Наследование и Super

Реализация классов не была бы полной без наследования в какой-либо форме, и CoffeeScript, естественно, реализовал его. Вы можете унаследовать класс от другого, используя ключевое слово extends. В примере ниже Parrot наследуется от Animal, получая все его свойства и методы, такие как alive().

```coffeescript
class Animal
  constructor: (@name) ->

  alive: ->
    false

class Parrot extends Animal
  constructor: ->
    super("Parrot")

  dead: ->
    not @alive()
```

В примере выше, как вы могли заметить, мы используем ключевое слово super(). "За кулисами" происходит вызов функции прототипа родительского класса, выполненный в текущем контексте. В данном случае это будет Parrot.__super__.constructor.call(this, "Parrot");. На практике, эффект будет точно такой же, как при вызове super в Ruby или Python, вызовется переопределенная унаследованная функция.

Если вы не переопределили конструктор, по умолчанию CoffeeScript вызовет конструктор родителя в момент создания экземляра класса.

CoffeeScript использует прототипное наследование, чтобы автоматически унаследовать все свойства экземпляра класса. Это гарантирует динамичность классов. Даже если вы добавите свойства в родительский класс после того как был создан наследник, свойство распространится на все унаследованные классы.

```coffeescript
class Animal
  constructor: (@name) ->

class Parrot extends Animal

Animal::rip = true

parrot = new Parrot("Macaw")
alert("This parrot is no more") if parrot.rip
```

Хотя стоит отметить, что статические свойства копируются в дочерние классы, вместо наследования через прототипы, как это делается со свойствами экземпляров классов. Так получилось из-за деталей реализации прототипной архитектуры в Javascript, и обойти эту проблему довольно трудно.

###Примеси

CoffeeScript не поддерживает примеси "из коробки", но вы можете довольно легко реализовать их самостоятельно. Например, две функции, extend() и include(),
которые добавляют свойства классу и экземплярам класса соотвественно.

```coffeescript
extend = (obj, mixin) ->
  obj[name] = method for name, method of mixin        
  obj

include = (klass, mixin) ->
  extend klass.prototype, mixin

# Usage
include Parrot,
  isDeceased: true

(new Parrot).isDeceased
```

[Примеси][0] - это отличный паттерн, который пригодится для использования общей логики между модулями в тот момент, когда вы не можете использовать наследование. Преимущество примесей в том, что вы можете включить в объект логику нескольких объектов, тогда как унаследоваться можно только от одного.

###Расширение классов

Применение примесей выглядят довольно изящно, но они не достаточно объектно-ориентированы. Но мы можем интегрировать примеси в CoffeeScript классы. Попробуем определить класс, именуемый Module, от которого мы сможем унаследоваться для поддержки примесей. Module будет иметь два статических метода, @extend() и @include(), которые будут использоваться для расширения классов статическими свойствами и свойствами экземпляров класса соотвественно.

```coffeescript
moduleKeywords = ['extended', 'included']

class Module
  @extend: (obj) ->
    for key, value of obj when key not in moduleKeywords
      @[key] = value

    obj.extended?.apply(@)
    this

  @include: (obj) ->
    for key, value of obj when key not in moduleKeywords
      # Assign properties to the prototype
      @::[key] = value

    obj.included?.apply(@)
    this
```

Придется немного "потанцевать" с переменной moduleKeywords, чтобы гарантировать поддержку функции обратного вызова после расширения класса. Посмотрим на наш класс Module в действии:

```coffeescript
classProperties = 
  find: (id) ->
  create: (attrs) ->

instanceProperties =
  save: -> 

class User extends Module
  @extend classProperties
  @include instanceProperties

# Usage:
user = User.find(1)

user = new User
user.save()
```

Как вы можете видеть, мы добавили несколько статических свойств, find() и create() в класс User, а также метод экземпляра save(). Поскольку у нас есть функции обратного вызова, которые выполняются, когда модули расширяются, мы можете сократить процесс добавления статических свойств и свойства экземпляра:

```coffeescript
ORM = 
  find: (id) ->
  create: (attrs) ->
  extended: ->
    @include
      save: -> 

class User extends Module
  @extend ORM
```

Очень просто и элегантно!

[0]: https://ru.wikipedia.org/wiki/Примесь_(программирование)





