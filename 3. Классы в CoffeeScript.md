На приверженцев чисто объектно ориентированных языков классы в JavaScript действуют, как чеснок на Дракулу (хотя в ряд ли Вы бы стали читать книгу по CoffeeScript, придерживайся Вы таких взглядов). Однако классы в JavaScript столь же полезны, сколь и в других языках, а CoffeeScript сильно упрощает работу с ними.

"За кулисами" CoffeeScript использует прототипирование JavaScript'а для создания классов, добавляя немного синтаксического сахара при наследовании статических свойств и определении контекста исполнения. Все что требуется написать разработчику - это:

```coffeescript
class Animal
```

В приведенном примере Animal - это название класса и одновременно полученной переменной, которую в дальнейшем можно использовать для создания экземпляров класса. Внутри CoffeeScript использует функции-конструкторы, что позволяет создавать объекты с помощью оператора `new`:

```coffeescript
animal = new Animal
```

Создать конструктор (функцию, вызываемую при создании экземпляра класса) очень просто - создайте функцию с именем `constructor`, аналогично методу `initialize` в Ruby или `__init__` в Python:

```coffeescript
class Animal
  constructor: (name) ->
    @name = name
```

Более того, CoffeeScript предоставляет элегантную реализацию распространненного способа установки исходных значений полей объекта. Префикс `@` автоматически превращает переменную в свойство экземпляра класса. На самом деле, этот синтаксический сахар работает даже для обыкновенных функций за пределами класса. Пример, приведенный ниже эквивалентен предыдущему:

```coffeescript
class Animal
  constructor: (@name) ->
```

Таким образом переменные, передаваемые при создании объекта, транслируются в конструктор:

```coffeescript
animal = new Animal("Parrot")
alert "Animal is a #{animal.name}
```

### Поля объекта

Добавление дополнительных свойста в объект класса является довольно прямолинейно: оно полностью совпадает с добавление свойств в обычный объект. Нужно только убедиться, что свойства добавлены тело класса.

```coffeescript
class Animal
  price: 5

  sell: (customer) ->

animal = new Animal
animal.sell(new Customer)
```

В JavaScript часто приходится прибегать к смене контекста. В главе Синтакис мы уже рассказывали о том, как привязать значение this к конкретному контексту, используя толстую стрелку =>. Так мы гарантируем, что функция будет выполняться в том контексте, в котором была создана, независимо от контекста, в котором она вызывается. CoffeeScript расширяет поддержку толстой стрелки для классов. Используя ее для методов объекта, мы гарантируем, что метод будет вызываться в контексте текущего объекта класса.

```coffeescript
class Animal
  price: 5

  sell: =>
    alert "Give me #{@price} shillings!"

animal = new Animal
$("#sell").click(animal.sell)
```

В примере, показаном выше, видно, что этот прием особенно полезент в функциях обратного вызова для событий. Если бы мы использовали тонкую стрелку, метод sell() был бы вызван в контексте элемента #sell. В нашем же случае мы гарантируем, что используется корректный контекст и this.price равен 5.

###Статические свойства

How about defining class (i.e. static) properties? Well, it turns out that inside a class definition, this refers to the class object. In other words you can set class properties by setting them directly on this.

А что на счет статических свойств? В CoffeeScript внутри определения класса this ссылается на сам объект класса. Другими словами, вы можете задать статические свойства класса, установив их непосредственно через this.

```coffeescript
class Animal
  this.find = (name) ->      

Animal.find("Parrot")
```

In fact, as you may remember, CoffeeScript aliases this to @, which lets you write static properties even more succinctly:
Вы уже знаете, что в CoffeeScript существует ??алиас??(псевдоним, синоним) для this - @, который позволяет нам писать статические свойства еще более кратко:

```coffeescript
class Animal
  @find: (name) ->

Animal.find("Parrot")
```

###Наследование и Super

Реализация классов не была бы полной без наследования в какой-либо форме, и CoffeeScript, естественно, реализовал его. Вы можете унаследовать класс от другого, используя ключевое слово extends. В примере ниже Parrot наследуется от Animal, получая все его свойства и методы, такие как alive().

```coffeescript
class Animal
  constructor: (@name) ->

  alive: ->
    false

class Parrot extends Animal
  constructor: ->
    super("Parrot")

  dead: ->
    not @alive()
```

В примере выше, как вы могли заметить, мы используем ключевое слово super(). "За кулисами" происходит вызов функции прототипа родительского класса, выполненный в текущем контексте. В данном случае это будет Parrot.__super__.constructor.call(this, "Parrot");. На практике, эффект будет точно такой же, как при вызове super в Ruby или Python, вызовется переопределенная унаследованная функция.

Если вы не переопределили конструктор, по умолчанию CoffeeScript вызовет конструктор родителя в момент создания экземляра класса.

CoffeeScript использует прототипное наследование, чтобы автоматически унаследовать все свойства экземпляра класса. Это гарантирует динамичность классов. Даже если вы добавите свойства в родительский класс после того как был создан наследник, свойство распространится на все унаследованные классы.

```coffeescript
class Animal
  constructor: (@name) ->

class Parrot extends Animal

Animal::rip = true

parrot = new Parrot("Macaw")
alert("This parrot is no more") if parrot.rip
```

Хотя стоит отметить, что статические свойства копируются в дочерние классы, вместо наследования через прототипы, как это делается со свойствами экземпляров классов. Так получилось из-за деталей реализации прототипной архитектуры в Javascript, и обойти эту проблему довольно трудно.










