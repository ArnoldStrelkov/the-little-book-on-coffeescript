##Основы диалекта CoffeeScript

У каждого языка есть присущий ему диалект и набор практик, и CoffeeScript не является исключением. В этой главе будет рассмотрено использование таковых и проведено несколько сравнений Javascript и CoffeeScript, чтобы вы смогли уловить практический смысл языка.

###Each

Чтобы перебрать все элементы массива в Javascript, можно использовать либо недавно добавленный метод [forEach()][0], либо старый добрый цикл for в стиле C. Если вы планируете использовать последние возможности JavaScript'а, представленные в ECMAScript 5, я советую подключить к странице ??[shim][1]??, чтобы эмулировать поддержку в старых браузерах.

```javascript
for (var i=0; i < array.length; i++)
  myFunction(array[i]);

array.forEach(function(item, i){
  myFunction(item)
});
```

Несмотря на то, что синтаксис метода forEach() намного более сжатый и читабельный, у него существует недостаток: вызов функции будет происходить на каждой итерации массива, и поэтому этот вариант является более медленным, чем использование цикла. Посмотрим, как это выглядит в CoffeeScript.

```coffeescript
myFunction(item) for item in array
```

Я уверен, вы согласитесь,что это краткая и читабельная запись, и, что особенно важно, она компилируется в цикл for. Другими словами, синтаксис CoffeeScript предлагает такую же выразительность, как и forEach(), но без потери скорости.

###Map

Так же, как и в случае с forEach(), ES5 включает в себя нативную реализацию функции [map()][2], которая имеет более короткий синтаксис, чем классический цикл. К сожалению, она имеет те же недостатки, что и forEach(): скорость ее выполнения заметно ниже из-за вызовов функции.

```javascript
var result = []
for (var i=0; i < array.length; i++)
  result.push(array[i].name)

var result = array.map(function(item, i){
  return item.name;
});
```

Как уже упоминалось в главе о синтаксисе, генераторы массивов в CoffeeScript можно использовать для достижения поведения, схожего с map(). Обратите внимание, что мы заключаем генератор в скобки. Это гарантирует, что генератор вернет именно то, что мы оижадем.

```coffeescript
result = (item.name for item in array)
```

### Фильтрация

Также в ES5 входит функция [filter()][3] для фильтрации массивов:

```javascript
var result = []
for (var i=0; i < array.length; i++)
  if (array[i].name == "test")
    result.push(array[i])

result = array.filter(function(item, i){
  return item.name == "test"
});
```

В синтаксисе CoffeeScript есть ключевое слово when, которое используется для фильтрация с помощью сравнения значений. После компиляции данное выражение превращается в цикл for. Код оборачивается в анонимную функцию во избежание утечек памяти и конфликтов имен.

```coffeescript
result = (item for item in array when item.name is "test")
```

Не забывайте использовать скобки, иначе результатом выполнения будет последний элемент массива. Генераторы в CoffeeScript очень гибки и позволяют вам делать интересные выборки, такие как в следующем примере:

```coffeescript
passed = []
failed = []
(if score > 60 then passed else failed).push score for score in [49, 58, 76, 82, 88, 90]

# Or
passed = (score for score in scores when score > 60)
```

Если выражения получаются слишком длинными, можно разбить их на несколько строк.

```coffeescript
passed = []
failed = []
for score in [49, 58, 76, 82, 88, 90]
  (if score > 60 then passed else failed).push score
```

###Вхождения

Для того, чтобы проверить, входит ли значение в массив, обычно используют метод indexOf(), который требует подключение ??shim??, так как Internet Explorer до сих пор не реализовал его.

```javascript
var included = (array.indexOf("test") != -1)
```

В качестве альтернативы в CoffeeScript присутствует оператор "in".

```coffeescript
included = "test" in array
```

На самом деле, CoffeeScript использует Array.prototype.indexOf(), по необходимости ??shimming??, чтобы определить, присутствует ли значение в массиве. К сожалению, это означет, что данный способ невозможно использовать при работе со строками. В такой ситуации придется вернуться к использованию indexOf() и проверке, является ли результат отрицательным.

```coffeescript
included = "a long test string".indexOf("test") isnt -1
```

Есть метод и получше: можно использовать побитовые операторы, чтобы избежать сравнения с -1.

```coffeescript
string   = "a long test string"
included = !!~ string.indexOf "test"
```

###Перебор свойств

Для перебора свойств объекта в JavaScript обычно используется оператор in. Например:

```javascript
var object = {one: 1, two: 2}
for(var key in object) alert(key + " = " + object[key])
```

Как вы могли заметить в предыдущей секции, в CoffeeScript оператор in уже зарезервирован для взаимодействия с массивами. Вместо него был введен оператор of, который используется следующим образом:

```coffeescript
object = {one: 1, two: 2}
alert("#{key} = #{value}") for key, value of object
```

Особенность данного способа заключается в том, что вы можете определить переменные и для имен свойств, и для их значений.

###Min/Max

??Данная техника не является специфичной для CoffeeScript??, но я думаю будет полезно продемонстрировать ее. Math.max и Math.min принимают несколько аргументов, поэтому вы можете воспользоваться ..., чтобы передать в них массив, и получить его минимальное и максимальное значение.

```coffeescript
Math.max [14, 35, -7, 46, 98]... # 98
Math.min [14, 35, -7, 46, 98]... # -7
```

Стоит отметить, что этот трюк не сработает на по-настоящему больших массивах, та как браузеры ограничивают количество аргументов, передаваемых в функции.

###Множественные аргументы

Выше, в примере с Math.max, мы использовали ..., чтобы развернуть массив в последовательность переменных и передать их как множество аргументов в функцию max. При компиляции CoffeeScript конвертирует вызов функции в применение метода apply(), обеспечиваю передачу массива в виде нескольких аргментов. Мы можем использовать эту особенность и в других случаях, например при проксировании вызова функции:

```coffeescript
Log =
  log: ->
    console?.log(arguments...)
```

Или вы можете изменить аргументы, прежде чем передать их далее:

```coffeescript
Log =
  logPrefix: "(App)"

  log: (args...) ->
    args.unshift(@logPrefix) if @logPrefix
    console?.log(args...)
```

Нужно иметь в виду, что CoffeeScript автоматически установит в качестве контекста выполнения функции объект,?? функция которого вызывается в данный момент,?? в нашем случае sonsole. Если хотите сами установить контекст выполнения, потребуется применить функцию apply() вручную.

###И/Или

В руководстве по стилю CoffeeScript указывается, что использование оператора or является более предпочтительным, чем ||.  То же относится и к паре and и &&, так как первые варианты более читабельны. Тем не менее, оба стиля дают одни и те же результаты.

Предпочтение в сторону более "Английского" стиля кода также относится и к использованию is вместо == и isnt вместо !=.
```coffeescript

string = "migrating coconuts"
string == string # true
string is string # true
```

Одной по-настоящему крутой особенностью CoffeeScript стало появление паттерна ??"или присвоить"??, в котором рубисты узнают знакомый им ||=.

```coffeescript
hash or= {}
```

Если значением переменной hash является false, ей присваивается пустой объект. Важно отменить, что это выражение определяет 0, "" и null как false. Если ваш замысел отличается от этого, вам следует использовать операторор сущетвования, который срабатывает, только если значением hash является undefined или null.

```coffeescript
hash ?= {}
```

###Реструктурирующее присваивание

Реструктурирующее присваивание можно применять к массивам и объектам любого уровня вложенности, чтобы помочь вытащить глубоко вложенные свойства и элементы.

```coffeescript
someObject = { a: 'value for a', b: 'value for b' }
{ a, b } = someObject
console.log "a is '#{a}', b is '#{b}'"
```

Оно особенно полезно в Node.js приложениях при подключении модулей:

```coffeescript
{join, resolve} = require('path')

join('/Users', 'Alex')
```

###Внешние библиотеки

Так как в конце концов весь CoffeeScript код компилируется в JavaScript, использование внешних библиотек сводится к простому вызову функций. [jQuery][4] в CoffeeScript используется особенно элегантно из за количетва функций обратного вызова в API jQuery.

```coffeescript
# Use local alias
$ = jQuery

$ ->
  # DOMContentLoaded
  $(".el").click ->
    alert("Clicked!")
```

Так как скомпилированный из CoffeeScript код оборачивается в анонимную функцию, мы можем задать локальный алиас $ для jQuery. После этого мы можем быть уверены, даже если включен no-conflict режим jQuery и переменная $ была переопределена, результат останется именно таким, каким мы его подразумевали.

###Приватные переменные

В CoffeeScript есть ключевое слово do. Оно позволяет обернуть код в немедленно вызываемую функцию, что является отличным способом инкапсуляции и защиты переменных. В примере ниже мы определяем переменную classToType в контексте анонимной функции, которая немедленно вызывается с помощью do. Эта анонимная функция возвращает другую анонимную функцию, которая вернет окончательное значение типа. Так как classToType была определена в контексте, ссылок на который не существует, она будет недоступна снаружи данного замыкания.

```coffeescript
# Execute function immediately
type = do ->
  classToType = {}
  for name in "Boolean Number String Function Array Date RegExp Undefined Null".split(" ")
    classToType["[object " + name + "]"] = name.toLowerCase()

  # Return a function
  (obj) ->
    strType = Object::toString.call(obj)
    classToType[strType] or "object"
```

Другими словами, classToType является полностью приватной переменной, и на нее нельзя ссылаться снаружи выполняющейся анонимной функции. Этот шаблон - отличный способ инкапсуляции.



[0]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
[1]: https://github.com/es-shims/es5-shim
[2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
[3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
[4]: http://jquery.com/