##Основы диалекта CoffeeScript

У каждого языка есть присущий ему диалект и набор практик, и CoffeeScript не является исключением. В этой главе будет рассмотрено использование таковых и проведено несколько сравнений Javascript и CoffeeScript, чтобы вы смогли уловить практический смысл языка.

###Each

Чтобы перебрать все элементы массива в Javascript, можно использовать либо недавно добавленный метод [forEach()][0], либо старый добрый цикл for в стиле C. Если вы планируете использовать последние возможности JavaScript'а, представленные в ECMAScript 5, я советую подключить к странице ??shim??, чтобы эмулировать поддержку в старых браузерах.

```javascript
for (var i=0; i < array.length; i++)
  myFunction(array[i]);

array.forEach(function(item, i){
  myFunction(item)
});
```

Несмотря на то, что синтаксис метода forEach() намного более сжатый и читабельный, у него существует недостаток: вызов функции будет происходить на каждой итерации массива, и поэтому этот вариант является более медленным, чем использование цикла. Посмотрим, как это выглядит в CoffeeScript.

```coffeescript
myFunction(item) for item in array
```

Я уверен, вы согласитесь,что это краткая и читабельная запись, и, что особенно важно, она компилируется в цикл for. Другими словами, синтаксис CoffeeScript предлагает такую же выразительность, как и forEach(), но без потери скорости.

###Map

Так же, как и в случае с forEach(), ES5 включает в себя нативную реализацию функции map, которая имеет более короткий синтаксис, чем классический цикл. К сожалению, она имеет те же недостатки, что и forEach(): скорость ее выполнения заметно ниже из-за вызовов функции.

```javascript
var result = []
for (var i=0; i < array.length; i++)
  result.push(array[i].name)

var result = array.map(function(item, i){
  return item.name;
});
```

Как уже упоминалось в главе о синтаксисе, генераторы массивов в CoffeeScript можно использовать для достижения поведения, схожего с map(). Обратите внимание, что мы заключаем генератор в скобки. Это гарантирует, что генератор вернет именно то, что мы оижадем.

```coffeescript
result = (item.name for item in array)
```

### Фильтрация

Также в ES5 входит функция filter() для фильтрации массивов:

```javascript
var result = []
for (var i=0; i < array.length; i++)
  if (array[i].name == "test")
    result.push(array[i])

result = array.filter(function(item, i){
  return item.name == "test"
});
```

В синтаксисе CoffeeScript есть ключевое слово when, которое используется для фильтрация с помощью сравнения значений. После компиляции данное выражение превращается в цикл for. Код оборачивается в анонимную функцию во избежание утечек памяти и конфликтов имен.

```coffeescript
result = (item for item in array when item.name is "test")
```

Не забывайте использовать скобки, иначе результатом выполнения будет последний элемент массива. Генераторы в CoffeeScript очень гибки и позволяют вам делать интересные выборки, такие как в следующем примере:

```coffeescript
passed = []
failed = []
(if score > 60 then passed else failed).push score for score in [49, 58, 76, 82, 88, 90]

# Or
passed = (score for score in scores when score > 60)
```

Если выражения получаются слишком длинными, можно разбить их на несколько строк.

```coffeescript
passed = []
failed = []
for score in [49, 58, 76, 82, 88, 90]
  (if score > 60 then passed else failed).push score
```

###Вхождения

Для того, чтобы проверить, входит ли значение в массив, обычно используют метод indexOf(), который требует подключение ??shim??, так как Internet Explorer до сих пор не реализовал его.

```javascript
var included = (array.indexOf("test") != -1)
```

В качестве альтернативы в CoffeeScript присутствует оператор "in".

```coffeescript
included = "test" in array
```

На самом деле, CoffeeScript использует Array.prototype.indexOf(), по необходимости ??shimming??, чтобы определить, присутствует ли значение в массиве. К сожалению, это означет, что данный способ невозможно использовать при работе со строками. В такой ситуации придется вернуться к использованию indexOf() и проверке, является ли результат отрицательным.

```coffeescript
included = "a long test string".indexOf("test") isnt -1
```

Есть метод и получше: можно использовать побитовые операторы, чтобы избежать сравнения с -1.

```coffeescript
string   = "a long test string"
included = !!~ string.indexOf "test"
```

###Перебор свойств

Для перебора свойств объекта в JavaScript обычно используется оператор in. Например:

```javascript
var object = {one: 1, two: 2}
for(var key in object) alert(key + " = " + object[key])
```

Как вы могли заметить в предыдущей секции, в CoffeeScript оператор in уже зарезервирован для взаимодействия с массивами. Вместо него был введен оператор of, который используется следующим образом:

```coffeescript
object = {one: 1, two: 2}
alert("#{key} = #{value}") for key, value of object
```

Особенность данного способа заключается в том, что вы можете определить переменные и для имен свойств, и для их значений.

###Min/Max

??Данная техника не является специфичной для CoffeeScript??, но я думаю будет полезно продемонстрировать ее. Math.max и Math.min принимают несколько аргументов, поэтому вы можете воспользоваться ..., чтобы передать в них массив, и получить его минимальное и максимальное значение.

```coffeescript
Math.max [14, 35, -7, 46, 98]... # 98
Math.min [14, 35, -7, 46, 98]... # -7
```

Стоит отметить, что этот трюк не сработает на по-настоящему больших массивах, та как браузеры ограничивают количество аргументов, передаваемых в функции.

###Множественные аргументы

Выше, в примере с Math.max, мы использовали ..., чтобы развернуть массив в последовательность переменных и передать их как множество аргументов в функцию max. При компиляции CoffeeScript конвертирует вызов функции в применение метода apply(), обеспечиваю передачу массива в виде нескольких аргментов. Мы можем использовать эту особенность и в других случаях, например при проксировании вызова функции:

```coffeescript
Log =
  log: ->
    console?.log(arguments...)
```

Или вы можете изменить аргументы, прежде чем передать их далее:

```coffeescript
Log =
  logPrefix: "(App)"

  log: (args...) ->
    args.unshift(@logPrefix) if @logPrefix
    console?.log(args...)
```

Нужно иметь в виду, что CoffeeScript автоматически установит в качестве контекста выполнения функции объект,?? функция которого вызывается в данный момент,?? в нашем случае sonsole. Если хотите сами установить контекст выполнения, потребуется применить функцию apply() вручную.

###И/Или

###Destructuring assignments?

###Внешние библиотеки

###Приватные переменные




[0]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach