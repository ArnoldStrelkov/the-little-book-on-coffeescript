##Основы диалекта CoffeeScript

У каждого языка есть присущий ему диалект и набор практик, и CoffeeScript не является исключением. В этой главе будет рассмотрено использование таковых и проведено несколько сравнений Javascript и CoffeeScript, чтобы вы смогли уловить практический смысл языка.

###Each

Чтобы перебрать все элементы массива в Javascript, можно использовать либо недавно добавленный метод [forEach()][0], либо старый добрый цикл for в стиле C. Если вы планируете использовать последние возможности JavaScript'а, представленные в ECMAScript 5, я советую подключить к странице ??shim??, чтобы эмулировать поддержку в старых браузерах.

```javascript
for (var i=0; i < array.length; i++)
  myFunction(array[i]);

array.forEach(function(item, i){
  myFunction(item)
});
```

Несмотря на то, что синтаксис метода forEach() намного более сжатый и читабельный, у него существует недостаток: вызов функции будет происходить на каждой итерации массива, и поэтому этот вариант является более медленным, чем использование цикла. Посмотрим, как это выглядит в CoffeeScript.

```coffeescript
myFunction(item) for item in array
```

Я уверен, вы согласитесь,что это краткая и читабельная запись, и, что особенно важно, она компилируется в цикл for. Другими словами, синтаксис CoffeeScript предлагает такую же выразительность, как и forEach(), но без потери скорости.

###Map

Так же, как и в случае с forEach(), ES5 включает в себя нативную реализацию функции map, которая имеет более короткий синтаксис, чем классический цикл. К сожалению, она имеет те же недостатки, что и forEach(): скорость ее выполнения заметно ниже из-за вызовов функции.

```javascript
var result = []
for (var i=0; i < array.length; i++)
  result.push(array[i].name)

var result = array.map(function(item, i){
  return item.name;
});
```

Как уже упоминалось в главе о синтаксисе, генераторы массивов в CoffeeScript можно использовать для достижения поведения, схожего с map(). Обратите внимание, что мы заключаем генератор в скобки. Это гарантирует, что генератор вернет именно то, что мы оижадем.

```coffeescript
result = (item.name for item in array)
```

### Фильтрация

Также в ES5 входит функция filter() для фильтрации массивов:

```javascript
var result = []
for (var i=0; i < array.length; i++)
  if (array[i].name == "test")
    result.push(array[i])

result = array.filter(function(item, i){
  return item.name == "test"
});
```

В синтаксисе CoffeeScript есть ключевое слово when, которое используется для фильтрация с помощью сравнения значений. После компиляции данное выражение превращается в цикл for. Код оборачивается в анонимную функцию во избежание утечек памяти и конфликтов имен.

```coffeescript
result = (item for item in array when item.name is "test")
```

Не забывайте использовать скобки, иначе результатом выполнения будет последний элемент массива. Генераторы в CoffeeScript очень гибки и позволяют вам делать интересные выборки, такие как в следующем примере:

```coffeescript
passed = []
failed = []
(if score > 60 then passed else failed).push score for score in [49, 58, 76, 82, 88, 90]

# Or
passed = (score for score in scores when score > 60)
```

Если выражения получаются слишком длинными, можно разбить их на несколько строк.

```coffeescript
passed = []
failed = []
for score in [49, 58, 76, 82, 88, 90]
  (if score > 60 then passed else failed).push score
```

###Вхождения

###Перебор свойств

###Min/Max

###Множественные аргументы

###И/Или

###Destructuring assignments?

###Внешние библиотеки

###Приватные переменные




[0]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach